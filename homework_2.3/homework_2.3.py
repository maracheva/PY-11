#coding: utf-8

import json
from pprint import pprint
# Запишем все файлы json, которые нужно отсортировать, в список словарей:
files = [
    {'name': 'newsafr.json', 'encoding': 'utf-8'},
    {'name': 'newscy.json', 'encoding': 'koi8_r'},
    {'name': 'newsfr.json', 'encoding': 'cyrillic'},
    {'name': 'newsit.json', 'encoding': 'cp1251'},
]
# Интерпретатор запускает некоторый модуль (исходный файл) как основную программу,
# он присваивает специальной переменной __name__ значение '__main__'.
# Весь код, который не должен исполняться при импорте исходного файла, поместим в блок if __name__ == ‘__main__’:.
# __name__ — это специальная внутренняя переменная, которая инициализируется, как ‘__main__’,
# если файл с исходным кодом был непосредственно запущен, а не импортирован.
# При импорте, переменная будет содержать имя модуля, из которого произошел импорт.
# Т.е. зададим условие, задача которого - разделение кода, который будет выполнятся при вызове кода как модуля
# (при импортировании его в другой скрипт) и при запуске самого модуля, как отдельного файла.
if __name__ == '__main__':
# Цикл открытия файлов:
    for news_text in files:
        with open(news_text['name'], 'r', encoding = news_text['encoding']) as file:
            news = json.load(file) # зададим переменную news и загрузим файлы с текстом

# Информация в файлах json передается в виде словаря.
# 'rss' - ключ основного словаря, который состоит из других словарей.
    # 'channel' - ключ словаря 'rss'.
        # 'items' - ключ словаря 'channel'.
        # 'description' - ключ списка словарей в 'items'.
        # 'title' - ключ списка словарей в 'items'. По ключу 'title' можно не делать поиск,
        # т.к. title является заголовком, т.е. краткой выжимкой из основного текста discription.
        # Остальные ключи не содержат текст, поэтому не будем проводить по ним поиск слов.
# Добавим новый словарь, куда будем записывать слова > 6 символов.
        words = {}
        for item in news['rss']['channel']['items']:
            for word in item['description'].split() and item['title'].split():
                if len(word) > 6:
                    word = word.lower()
                    if word in words:
                        words[word] += 1
                    else:
                        words[word] = 1
# Получим отсортированный список словарных ключей с помощью sorted() (элементов словаря word с использованием ключа):
# key = words.get - получаем значение по ключу, в случае отсутствия получаем None;
# reverse = True - сортировка в обратном порядке
        words_sorted_keys = sorted(words, key = words.get, reverse = True)
        print('\n{:-^50}'.format(news_text['name']))
        for number, word in enumerate(words_sorted_keys[:10]):
            print('{:>2}. {}'.format(number+1, word))


# rss (англ. Rich Site Summary — обогащённая сводка сайта) — семейство XML-форматов,
# предназначенных для описания лент новостей, анонсов статей, изменений в блогах и т. п.

# channel - элемент содержит информацию о сайте источника.
# Внутри элемента rss содержится элемент channel, который включает информацию об источнике и его содержание.

# item - Новостное сообщение. Каждый item описывает только одно сообщение.
# В channel может содержаться любое количество элементов item.

# description - описание rss-канала одним предложением.
# title - название RSS-канала.