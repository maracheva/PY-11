1. Перестроить заданный связанный список (LinkedList) в обратном порядке.
   Для этого использовать метод `LinkedList.reverse()`, представленный в данном файле.
Ответ: 
См. файл homework_5.2.py.
В файле linked_list_reverse.py также реализован метод reverse. Результаты тестирования: Ran 1 test in 0.000s. 

2. Определить сложность алгоритма.
Ответ:
Сложность алгоритма О(1), т.к. имеем Bidirectional Linked List (двусвязанный список), т.е. в контейнерах есть ссылка 
не только на следующий, но и на предыдущий контейнер, что позволяет перемещаться по списку вперед и назад, что и делает метод reverse.
 
3. Определить потребление памяти в big-O notation.
Ответ:
При сложности алгоритма О(1) память не потребляется.

4. Изменится ли сложность и потребление памяти, если вместо связанного списка будет массив (array), и почему?
Ответ:
Реверс массива – это перестановка элементов в обратном порядке:
меняются местами первый и последний элементы, второй и предпоследний и т.д. 

Array (массив) — это коллекция фиксированного размера, состоящая из элементов одинакового типа.
Физически все элементы массива располагаются в памяти последовательно, 
и индекс элемента - это смещение в блоке памяти от его начала, поэтому извлечение элемента по индексу выполняется крайне быстро. 
Но так как память для стандартного массива выделяется на этапе компиляции, то и модифицировать его впоследствии уже нельзя.
Либо применять динамический массив.

List (список) — это коллекция элементов произвольного типа переменной длины (можно легко добавить или удалить элемент в список). 
Для связного списка память выделяется динамически, во время работы программы. 
Элементы в списке могут располагаться разряженно, неупорядоченно, что может вызывать проблемы с производительностью 
при выполнении динамических операций.

С учетом вышесказанного, делаем вывод, что использование списков больше влияет на потребление памяти, по сравнению с массивами, но 
у списков есть ряд преимуществ (быстрое добавление/удаление элемента в любом месте списка).

В нашей задаче, если реверс элементов списка (= О(1)) заменить на реверс массива (поиск по ключу = О(1)), 
то потребление памяти не измениться, т.к. сложность алгоритма О(1) не влияющает на память.

Хотя в правильности своего ответа окончательно я не уверена)
